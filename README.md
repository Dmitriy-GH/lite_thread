# lite_thread.h

Кросплатформенная библиотека на С++11 для легкого распараллеливания кода, в т.ч. потокоНЕбезопасного.

Все исходники и документация в lite_thread.h 

Библиотека построена по Модели Акторов, т.е. общий алгоритм разбивается на акторы (код, атомарные 
части бизнес-логики) и акторы общаются между собой пересылкой сообщений друг-другу. 

Библотека сама создает нужное количество потоков и запускает в них акторы. 

Библиотека гарантирует что актор не будет запущен одновременно в нескольких потоках, т.е. код актора 
не требует потокобезопасности. Но если актор потокобезопасный, то есть установка ограничения на 
количество одновременно работающих копий данного актора (см. lite_actor_parallel()). 
Также есть ограничение доступа группы акторов к конкретному ресурсу (процессор, память, сеть, БД и т.д.)

### Простейший пример использования

**void actor1(lite_msg_t* msg, void* env) {// Обработчик сообщения }**

void main() {

lite_msg_t* msg = lite_msg_create< int >(); // Создание сообщения 

int* x = lite_msg_data< int >(msg); // Указатель на содержимое сообщения

*x = 100500; // Заполнение сообщения

lite_thread_run(msg, actor1); //Отправка msg в actor1()

 lite_thread_end(); // Ожидание завершения работы

}


### Акторы
это или функция

**void recv(lite_msg_t* msg, void* env) {
 ... Обработка сообщения
}**

или класс, унаследованный от базового класса lite_worker_t 

**class worker_t : public lite_worker_t {
   void recv(lite_msg_t* msg) override {
       ... Обработка сообщения
   }
}**

И то и другое приводится к указателю на объект актора lite_actor_t*.

Для функций

**lite_actor_t* la = lite_actor_get(recv)**

Для классов, с созданием объекта

**lite_actor_t* la = lite_actor_create< worker_t >()** 

С созданием именованного объекта

**lite_actor_t* la = lite_actor_create< worker_t >("actor_name")**

Для именованных объектов всегда можно восстановить указатель:

**lite_actor_t* la = lite_actor_get("actor_name")**

Все объекты кэшируются библиотекой и удаляются при завершении ее работы, т.е. явного удаления не требуется.

### Сообщения
Для создания сообщения нужного размера

**lite_msg_t* msg = lite_msg_create(size, type)**

далее работа с msg->data

Для создания типизированного сообщения (пока только структуры, конструктор не запускается)

**lite_msg_t* msg = lite_msg_create< my_msg_t >(type)**

Получение указателя на содержимое типизированного сообщения

**my_msg_t* d = lite_msg_data< my_msg_t >(msg)**

далее работа с d->...

###Отправка сообщения

Отправка сообщения актору lite_actor_t* la

**lite_thread_run(msg, la)**

Удаление сообщений происходит автоматически. Библиотека отслеживает было ли входяшее сообщение 
отправлено далее. Если не было, то удаляет.
В случае если необходимо закэшировать сообщение внутри актора, то использовать копирование

**my_cache = lite_msg_copy(msg)**

но после использования необходимо явно удалить

**lite_msg_erase(my_cache)**

### МОЖНО
Менять сообщение и отправлять дальше. Библиотека гарантирует что сообщение обрабатывается 
только одним актором в одном потоке.

### НЕЛЬЗЯ
- Читать/писать сообщение после отправки, т.к. оно может быть уже в обработке получателем или удалено.
- Отправлять одно сообщение дважды.

### Рекомендации использования
Для избежания лишнего выделения памяти в начале лучше создать сообщение, учитывающее всю цепочку 
акторов, через которое оно пройдет, а в процессе прохождения цепочки каждый актор заполняет свою
часть сообщения и отправляет дальше. В реальности память будет выделена в момент отправки, а акторы 
будут просто пересылать указатель.

### Ограничение ресурсов
Акторы можно сгруппировать в соответствии с потребляемыми ими ресурсами (процессор, сеть, БД и т.д.)
Для создания ресурса 

**lite_resource_t* res = lite_resource_create("CPU", 8)**

где "CPU" название ресурса, 8 - максимальное количество акторов использующих ресурс.

Привязка актора к ресурсу

**la->resource_set(res)**

Библиотека гарантирует что все акторы привязанные к ресурсу "CPU" никогда не займут более 8 потоков, 
т.е. не будет выполняться более 8 акторов одновременно.

**Ограничение:** актор может быть привязан только к одному ресурсу.
Не привязанные к ресурсам акторы не имеют ограничений, т.е. будут выполнятся как только получат сообщение.

