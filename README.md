# lite_thread.h

Кросплатформенная библиотека на С++11 для легкого распараллеливания кода, в т.ч. потокоНЕбезопасного.

Все исходники и документация в lite_thread.h 

Библиотека построена по Модели Акторов, т.е. общий алгоритм разбивается на акторы (код, атомарные 
части бизнес-логики) и акторы общаются между собой пересылкой сообщений друг-другу. 

Библиотека сама создает нужное количество потоков и запускает в них акторы. 

Библиотека гарантирует что актор не будет запущен одновременно в нескольких потоках, т.е. код актора 
не требует потокобезопасности. Но если актор потокобезопасный (например актор без окружения, все 
необходимое для его работы содержится в сообщении), то его можно разрешить запускать одновременно в
разных потоках с установкой ограничения на количество параллельных запусков.

Есть ограничение доступа группы акторов к конкретному ресурсу. Например можно ограничить общее количество 
потоков для всех акторов активно использующих процессор.

Есть именование акторов, контроль типов сообщений, обработчик ошибок и ведение лога.

Высокая скорость передачи сообщений между акторами: например 40+ млн. сообшений в секунду в stress_test 
при ограничении 8 потоков на i7-3770К 3.5 ГГц

### Примеры использования

**test** примеры простейшего использования с выводом в консоль результата работы

**stress_test** нагрузочный тест для проверки работоспособности библиотеки

**card_raytracer** пример преобразования обычного последовательного алгоритма в алгоритм с использованием 
акторов и многопоточности.


### Простейший пример использования


	// Сообщение
	struct msg_t : public lite_msg_t {
		uint32_t x;
	};

	// Актор (обработчик сообщения)
	class actor_t : public lite_actor_t {
			void recv(lite_msg_t* m) override {
			msg_t* msg = dynamic_cast<msg_t*>(m);
			if(msg == NULL) ...				// Сообщение имеет другой тип, обработка ошибки 
			работа с msg
		}
	};

	void main() {
		actor_t* actor = new actor_t();				// Создание актора (обработчика)
		msg_t* msg = new msg_t;					// Создание сообщения
		msg->x = 100500;					// Заполнение сообщения
		actor->run(msg);					// Постановка в очередь на выполнение

		lite_thread_end();					// Ожидание завершения работы
	}